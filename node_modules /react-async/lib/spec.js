"use strict";

require("jest-dom/extend-expect");

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactTestingLibrary = require("react-testing-library");

var _ = require("./");

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

afterEach(_reactTestingLibrary.cleanup);

var resolveIn = function resolveIn(ms) {
  return function (value) {
    return new Promise(function (resolve) {
      return setTimeout(function () {
        return resolve(value);
      }, ms);
    });
  };
};
var resolveTo = resolveIn(0);
var rejectIn = function rejectIn(ms) {
  return function (err) {
    return new Promise(function (resolve, reject) {
      return setTimeout(function () {
        return reject(err);
      }, ms);
    });
  };
};
var rejectTo = rejectIn(0);

test("runs promiseFn on mount", function () {
  var promiseFn = jest.fn().mockReturnValue(Promise.resolve());
  (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { promiseFn: promiseFn }));
  expect(promiseFn).toHaveBeenCalledTimes(1);
});

test("passes resolved data to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
  var promiseFn, _render, getByText;

  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("done");
          };

          _render = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            function (_ref2) {
              var data = _ref2.data;
              return data || null;
            }
          )), getByText = _render.getByText;
          _context.next = 4;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 4:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, undefined);
})));

test("passes rejection error to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
  var promiseFn, _render2, getByText;

  return regeneratorRuntime.wrap(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          promiseFn = function promiseFn() {
            return Promise.reject("oops");
          };

          _render2 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            function (_ref4) {
              var error = _ref4.error;
              return error || null;
            }
          )), getByText = _render2.getByText;
          _context2.next = 4;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("oops");
          });

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  }, _callee2, undefined);
})));

test("passes the promise itself to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
  var promiseFn, _render3, getByText;

  return regeneratorRuntime.wrap(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("done");
          };

          _render3 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            function (_ref6) {
              var data = _ref6.data,
                  promise = _ref6.promise;

              if (data) {
                expect(promise).toBeInstanceOf(Promise);
                return data;
              }
              return null;
            }
          )), getByText = _render3.getByText;
          _context3.next = 4;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 4:
        case "end":
          return _context3.stop();
      }
    }
  }, _callee3, undefined);
})));

test("passes isLoading boolean while the promise is running", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
  var promiseFn, states, _render4, getByText;

  return regeneratorRuntime.wrap(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("done");
          };

          states = [];
          _render4 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            function (_ref8) {
              var data = _ref8.data,
                  isLoading = _ref8.isLoading;

              states.push(isLoading);
              return data || null;
            }
          )), getByText = _render4.getByText;
          _context4.next = 5;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 5:
          expect(states).toEqual([false, true, false]);

        case 6:
        case "end":
          return _context4.stop();
      }
    }
  }, _callee4, undefined);
})));

test("passes startedAt date when the promise starts", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
  var promiseFn, _render5, getByText;

  return regeneratorRuntime.wrap(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("done");
          };

          _render5 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            function (_ref10) {
              var startedAt = _ref10.startedAt;

              if (startedAt) {
                expect(startedAt.getTime()).toBeCloseTo(new Date().getTime(), -2);
                return "started";
              }
              return null;
            }
          )), getByText = _render5.getByText;
          _context5.next = 4;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("started");
          });

        case 4:
        case "end":
          return _context5.stop();
      }
    }
  }, _callee5, undefined);
})));

test("passes finishedAt date when the promise finishes", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
  var promiseFn, _render6, getByText;

  return regeneratorRuntime.wrap(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("done");
          };

          _render6 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            function (_ref12) {
              var data = _ref12.data,
                  finishedAt = _ref12.finishedAt;

              if (finishedAt) {
                expect(finishedAt.getTime()).toBeCloseTo(new Date().getTime(), -1);
                return data;
              }
              return null;
            }
          )), getByText = _render6.getByText;
          _context6.next = 4;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 4:
        case "end":
          return _context6.stop();
      }
    }
  }, _callee6, undefined);
})));

test("passes reload function that re-runs the promise", function () {
  var promiseFn = jest.fn().mockReturnValue(resolveTo());

  var _render7 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
    _2.default,
    { promiseFn: promiseFn },
    function (_ref13) {
      var reload = _ref13.reload;

      return _react2.default.createElement(
        "button",
        { onClick: reload },
        "reload"
      );
    }
  )),
      getByText = _render7.getByText;

  expect(promiseFn).toHaveBeenCalledTimes(1);
  _reactTestingLibrary.fireEvent.click(getByText("reload"));
  expect(promiseFn).toHaveBeenCalledTimes(2);
});

test("re-runs the promise when the value of 'watch' changes", function () {
  var Counter = function (_React$Component) {
    _inherits(Counter, _React$Component);

    function Counter() {
      var _temp, _this, _ret;

      _classCallCheck(this, Counter);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { count: 0 }, _this.inc = function () {
        return _this.setState(function (state) {
          return { count: state.count + 1 };
        });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Counter.prototype.render = function render() {
      return _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(
          "button",
          { onClick: this.inc },
          "increment"
        ),
        this.props.children(this.state.count)
      );
    };

    return Counter;
  }(_react2.default.Component);

  var promiseFn = jest.fn().mockReturnValue(resolveTo());

  var _render8 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
    Counter,
    null,
    function (count) {
      return _react2.default.createElement(_2.default, { promiseFn: promiseFn, watch: count });
    }
  )),
      getByText = _render8.getByText;

  expect(promiseFn).toHaveBeenCalledTimes(1);
  _reactTestingLibrary.fireEvent.click(getByText("increment"));
  expect(promiseFn).toHaveBeenCalledTimes(2);
  _reactTestingLibrary.fireEvent.click(getByText("increment"));
  expect(promiseFn).toHaveBeenCalledTimes(3);
});

test("runs deferFn only when explicitly invoked, passing arguments", function () {
  var counter = 1;
  var deferFn = jest.fn().mockReturnValue(resolveTo());

  var _render9 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
    _2.default,
    { deferFn: deferFn },
    function (_ref14) {
      var run = _ref14.run;

      return _react2.default.createElement(
        "button",
        { onClick: function onClick() {
            return run("go", counter++);
          } },
        "run"
      );
    }
  )),
      getByText = _render9.getByText;

  expect(deferFn).not.toHaveBeenCalled();
  _reactTestingLibrary.fireEvent.click(getByText("run"));
  expect(deferFn).toHaveBeenCalledWith("go", 1);
  _reactTestingLibrary.fireEvent.click(getByText("run"));
  expect(deferFn).toHaveBeenCalledWith("go", 2);
});

test("reload uses the arguments of the previous run", function () {
  var counter = 1;
  var deferFn = jest.fn().mockReturnValue(resolveTo());

  var _render10 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
    _2.default,
    { deferFn: deferFn },
    function (_ref15) {
      var run = _ref15.run,
          reload = _ref15.reload;

      return _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(
          "button",
          { onClick: function onClick() {
              return run("go", counter++);
            } },
          "run"
        ),
        _react2.default.createElement(
          "button",
          { onClick: reload },
          "reload"
        )
      );
    }
  )),
      getByText = _render10.getByText;

  expect(deferFn).not.toHaveBeenCalled();
  _reactTestingLibrary.fireEvent.click(getByText("run"));
  expect(deferFn).toHaveBeenCalledWith("go", 1);
  _reactTestingLibrary.fireEvent.click(getByText("run"));
  expect(deferFn).toHaveBeenCalledWith("go", 2);
  _reactTestingLibrary.fireEvent.click(getByText("reload"));
  expect(deferFn).toHaveBeenCalledWith("go", 2);
});

test("only accepts the last invocation of the promise", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
  var i, resolves, _render11, getByText;

  return regeneratorRuntime.wrap(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          i = 0;
          resolves = [resolveIn(10)("a"), resolveIn(20)("b"), resolveIn(10)("c")];
          _render11 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { deferFn: function deferFn(i) {
                return resolves[i];
              } },
            function (_ref17) {
              var data = _ref17.data,
                  run = _ref17.run;

              if (data) {
                expect(data).toBe("c");
                return "done";
              }
              return _react2.default.createElement(
                "button",
                { onClick: function onClick() {
                    return run(i);
                  } },
                "run"
              );
            }
          )), getByText = _render11.getByText;

          _reactTestingLibrary.fireEvent.click(getByText("run"));
          i++;
          _reactTestingLibrary.fireEvent.click(getByText("run"));
          i++;
          _reactTestingLibrary.fireEvent.click(getByText("run"));
          _context7.next = 10;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 10:
        case "end":
          return _context7.stop();
      }
    }
  }, _callee7, undefined);
})));

test("invokes onResolve callback when promise resolves", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
  var promiseFn, onResolve;
  return regeneratorRuntime.wrap(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          promiseFn = jest.fn().mockReturnValue(Promise.resolve("ok"));
          onResolve = jest.fn();

          (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { promiseFn: promiseFn, onResolve: onResolve }));
          _context8.next = 5;
          return Promise.resolve();

        case 5:
          expect(onResolve).toHaveBeenCalledWith("ok");

        case 6:
        case "end":
          return _context8.stop();
      }
    }
  }, _callee8, undefined);
})));

test("invokes onReject callback when promise rejects", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
  var promiseFn, onReject;
  return regeneratorRuntime.wrap(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          promiseFn = jest.fn().mockReturnValue(Promise.reject("err"));
          onReject = jest.fn();

          (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { promiseFn: promiseFn, onReject: onReject }));
          _context9.next = 5;
          return Promise.resolve();

        case 5:
          expect(onReject).toHaveBeenCalledWith("err");

        case 6:
        case "end":
          return _context9.stop();
      }
    }
  }, _callee9, undefined);
})));

test("cancels pending promise when unmounted", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
  var promiseFn, onResolve, _render12, unmount;

  return regeneratorRuntime.wrap(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          promiseFn = jest.fn().mockReturnValue(Promise.resolve("ok"));
          onResolve = jest.fn();
          _render12 = (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { promiseFn: promiseFn, onResolve: onResolve })), unmount = _render12.unmount;

          unmount();
          _context10.next = 6;
          return Promise.resolve();

        case 6:
          expect(onResolve).not.toHaveBeenCalled();

        case 7:
        case "end":
          return _context10.stop();
      }
    }
  }, _callee10, undefined);
})));

test("Async.Resolved renders only after the promise is resolved", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
  var promiseFn, _render13, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("done");
          };

          _render13 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            _react2.default.createElement(
              _2.default.Resolved,
              null,
              function (data) {
                return data;
              }
            )
          )), getByText = _render13.getByText, queryByText = _render13.queryByText;

          expect(queryByText("done")).toBeNull();
          _context11.next = 5;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 5:
          expect(queryByText("done")).toBeInTheDocument();

        case 6:
        case "end":
          return _context11.stop();
      }
    }
  }, _callee11, undefined);
})));

test("Async.Loading renders only while the promise is pending", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
  var promiseFn, _render14, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          promiseFn = function promiseFn() {
            return resolveTo("ok");
          };

          _render14 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            _react2.default.createElement(
              _2.default.Loading,
              null,
              "loading"
            ),
            _react2.default.createElement(
              _2.default.Resolved,
              null,
              "done"
            )
          )), getByText = _render14.getByText, queryByText = _render14.queryByText;

          expect(queryByText("loading")).toBeInTheDocument();
          _context12.next = 5;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("done");
          });

        case 5:
          expect(queryByText("loading")).toBeNull();

        case 6:
        case "end":
          return _context12.stop();
      }
    }
  }, _callee12, undefined);
})));

test("Async.Rejected renders only after the promise is rejected", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
  var promiseFn, _render15, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee13$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          promiseFn = function promiseFn() {
            return rejectTo("err");
          };

          _render15 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { promiseFn: promiseFn },
            _react2.default.createElement(
              _2.default.Rejected,
              null,
              function (err) {
                return err;
              }
            )
          )), getByText = _render15.getByText, queryByText = _render15.queryByText;

          expect(queryByText("err")).toBeNull();
          _context13.next = 5;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("err");
          });

        case 5:
          expect(queryByText("err")).toBeInTheDocument();

        case 6:
        case "end":
          return _context13.stop();
      }
    }
  }, _callee13, undefined);
})));